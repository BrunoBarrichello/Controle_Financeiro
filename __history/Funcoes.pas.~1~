unit Funcoes;

interface

uses
  Windows, Forms, Messages, SysUtils, Classes, Graphics, Vcl.Controls, Dialogs, DBGrids, Grids,
  StdCtrls, IBX.IBDatabase, DBClient, IBX.IBCustomDataSet, IBX.IBQuery, IBX.IBTable, ComObj, ACBrUtil, DB,
  TLHelp32, PsAPI, Registry, QuickRpt, ShellApi, Printers, DateUtils, variants;

type
  TEnderecosCliente = record
    Endereco: String;
    Objeto: TObject;
end;

  function TerminarProcesso(sFile: String): Boolean;
  procedure GravaCampo (vTabDest : TIBTable; vField, vOrig : String); Overload;
  procedure GravaCampo (vTabDest : TClientDataSet; vField, vOrig : String); Overload;
  procedure GravaCampo (vTabDest : TClientDataSet; vField: String; vOrig: Double); Overload;
  procedure Teclado1(Sender: TObject; var Key: Char; vNumero: Boolean);
  procedure Inserir_Bound(vCampo, vType : String);
  procedure Campo_Obrigatorio(Sender : TObject; vMsg : String);
  function ConverteBoolean(Campo :String) : Boolean;
  function Copia_ate_Caract(vCaract, vString : String; vRetornaApagado : Boolean) : String;
  function Arredonda_Centavos(vValor : String) : String;
  function IsNumeric(S : String) : Boolean;
  function Verificar_Valor(Campo :String) : Boolean;
  function GetWinDir: string;
  function Verifica_DiaUtil_data(Data:Tdate;Dias:integer):Tdate;
  function CaractBase(Temp1 : String) : String;
  function Caract(Temp1 : String) : String;
  function CaractADC(Temp1 : String) : String;
  function CalculaCPF_CNPJ(Numero: String): Boolean;
  function ValidaEAN(const vEAN:String):Boolean;
  function Centralizar_Texto_Impressao(texto:String; tamanho :Integer) :String;
  function MsgDlgButtonPersonal(const Msg: string; DlgType: TMsgDlgType; Buttons: TMsgDlgButtons; Captions: array of string): Integer;
  Function SeparaPalavras(Palavra, Campo: String): String;
  function ProdutoCalculaPrecoUnd(vOperacao :String; vIndice, vVista, vMarckup :double):double;
  function InputQueryArgus(const ACaption, APrompt: string; var Value: string; vMaxLenght:integer): Boolean;
  procedure Exibir_XML(vFile : String);
  procedure AbreForm(vClasseForm: TComponentClass;var vForm ; vPermi : String);
  procedure AbreFormConj(vClasseForm1: TComponentClass;var vForm1;vClasseForm2: TComponentClass;var vForm2);
  procedure AbreFormRecibo(vValor, vNome, vEnde, vVenc, vEmissao, vCompra, vObs : String);
  procedure AbreFormF5(vForm : String ; vDesco : Double);
  procedure AbreRelat(vClasseForm: TComponentClass;var vForm ; vPermi : String);
  procedure Vlr_Decimais(Sender : TObject);
  procedure DBGrid_CheckBox(Sender: TObject; vCampo, vValor : String; const Rect: TRect; DataCol: Integer; Column: TColumn; State: TGridDrawState);
  function PrgRodando(Executavel: WideString): Boolean; Export; StdCall;
  function Carrega_LogoBanco(sBanco :String):String;
  procedure LiberaMemoria;
  procedure AbreFormEnderecoEstoque(vForm, vCap :String);
  procedure AbrirArquivo(sCampo:String);
  function Procurar_Arq_Pasta(sPasta, sParteNome :string):String;
  function TiraPonto(sCampo:String):double;
  function EstoqueAtual(sOrdem:String):double;
  function EstoqueReservado(sOrdem, sPed:String):double;
  function Verifica_Impressora:boolean;
  function Ultimo_NossoNr(sBanco, sBancoDescri:String):string;
  procedure ExportaExcel( pTabela : TDataSet; pAutoFit: Boolean = True ) ;
  function SugestaoUCAF(sOrdem:double; sMes:integer):integer;
  procedure Verificar_Estoque_TableVendas(scampoest:string);
  function SaldoEstoqueUCAF(sOrdem:string; sEst, sQtde:double):boolean;
  function ValidaCaminho(vCaminho:TStringList):String;
  function OS_Excluida(sOS:double):boolean;
  function CustoMedio_AtacadoBetel(sOrdem, sCusto:double):double;
  Procedure SetGridVisivel(Grid:TDBGrid;vCampo:string; Visivel: Boolean);
  function VerificaColunaVisivel(vCampo:string; Grid: TDBGrid):Boolean;
  function Ultimo_NossoNrNovo(sBanco, sBancoDescri:string):string;
  function EstoqueEmProducao(sOrdem:double):integer;
  function VerificaSePodeBaixarPedido(ds:TIBTable):boolean;
  function PegaMes(mes:integer):string;
  procedure AbrirDetalheOrdemProducao(sOrdem:double);
  function Coalesce(Value1: Variant): Variant;
  var XLApp: Variant ;
  Function getNomeComputador: String;
  procedure UCAF_Contas_Pagar(stp:string);
  procedure CarregaPickListGrid(Campo, Tabela: String; GRID: TDBGrid; vNumColunaGrid: Integer);
  procedure HabilitaCapsLock;
  procedure ExcluiRegistro(vTabela, vCampo, vIndice: String);
  procedure CriarQry;
  function MontaEnderecosCli(vCodCli, CodigoContato, vIndice: integer):TEnderecosCliente;
  function flMessage(flMessage: String; fTitulo: String; flType: TMsgDlgType; flbutton: TMsgDlgButtons;
            flColor: TColor; flBold, flItalic: boolean; flFonte: TFontName): Integer;
  function ObterVersaoWindows: String;
  procedure AbrirWhatsApp(sTelefone, sArq:string; Janela: HWND);
  function VerificaControle_Abertura(vRotina, vChave_Serial: String; vNumero: Integer):String;
  procedure AtualizaControle_Abertura(vRotina, vChave_Serial, vOperacao: String; vNumero: Integer);
  Function GetWindowsDrive: Char;
  Function GerarSerialNum(FDrive: String): String;
  procedure LimparAcesso_Simul(vChave_Serial: String);
  procedure DimensionarGrid(dbg: TDBGrid);
  procedure AlterarCaptionTitleDBGrid(vCaption, vFieldColuna: String; vGrid: TDBGrid);
  procedure AlterarFieldDBGrid(vField_Antigo, vField_Novo: String; vGrid: TDBGrid);
  function SegundosToTime( Segundos : Cardinal ) : String;
  function VerificaMultiEmpresa:boolean;
  function Existe_Transferencia_Entre_Contas(vCont: Double):boolean;
  function Retorna_CF_Pedido(vNum_Pedido: Double): Double;
  procedure GravarEtiqueta(ordem:double; descri, op:string;qtde :integer; TIPO:string);
  function TrocaTermo_Cheque_Pix(vComponente: TLabel; vTermo: String): Boolean;
  function TabelaPrecoProduto(vordem: Double; vtabela: Integer):double;
  procedure VerificarEstornoCupomFiscal(cupom, nfe: integer; hora, sat_hora: ttime; seq_venda, chave_sat: string; sat_valor: double);
  function CaractData(Temp1 : String) : String;
	function AtualizarCustoPartsSeals(vCodProduto, vCodMaterial, vCustoMaterial : double):double;
	function VerificaCartaCorrecaoNFe(vNumNFE: String): Boolean;
	function QtdeItensPedido(vNumero: Integer): Integer;
  function RetornaDescricaoProdutoCliente(vordem, vcodcli: double; tabela, descricao:string): string;
	function calcularDiferencaHoras(Dataf,datai:Tdate;HoraF,HoraI:ttime):TDateTime;

Const
  xlWBATWorksheet = -4167;

implementation

uses UnitIntegra, cx02, Mad17, uEndeEstoque, Principal, uF5, uMemo, uEmissaoSAT, uMovimentaEstoque, Cam13, uPS_Inf_Prod_Cad, uPS_Inf_Prod_Cons;


function RetornaDescricaoProdutoCliente(vordem, vcodcli: double; tabela, descricao:string): string;
begin
	Tabelas.Inserir.Close;
  if tabela = 'orc'then
    Tabelas.Inserir.SQL.Text := 'SELECT O.DESCRICAO_PROD_CLI FROM ORC2SUB O ' +
    'INNER JOIN ORC2 C ON C.NUMERO=O.NUMERO ' +
    'WHERE O.ORDEM=:ORDEM AND C.CODCLI=:CODCLI ORDER BY O.CONT'
  else
    Tabelas.Inserir.SQL.Text := 'SELECT O.DESCRICAO_PROD_CLI FROM PEDIDOS001 O ' +
    'INNER JOIN PEDIDOS002 C ON C.NUMERO=O.NUMERO ' +
    'WHERE O.ORDEM=:ORDEM AND C.CODCLI=:CODCLI ORDER BY O.CONT';
	Tabelas.Inserir.ParamByName('ORDEM').AsFloat := vordem;
  Tabelas.Inserir.ParamByName('CODCLI').AsFloat := vcodcli;
	Tabelas.Inserir.Open;
  Tabelas.Inserir.last;
  if Tabelas.Inserir.RecordCount > 0 then begin
    if Tabelas.Inserir.fields[0].AsString <> '' then
      descricao:=Tabelas.Inserir.fields[0].AsString;
  end;

	Result := descricao;
	Tabelas.Inserir.Close;
end;

function QtdeItensPedido(vNumero: Integer): Integer;
begin
	Tabelas.Inserir2.Close;
	Tabelas.Inserir2.SQL.Text := 'SELECT COUNT(*) AS QTDE FROM VENDAS WHERE NUMERO=:NUMERO';
	Tabelas.Inserir2.ParamByName('NUMERO').AsInteger := vNumero;
	Tabelas.Inserir2.Open;
	Result := Tabelas.Inserir2.FieldByName('QTDE').AsInteger;
	Tabelas.Inserir2.Close;
end;

function VerificaCartaCorrecaoNFe(vNumNFE: String): Boolean;
begin
	if Trim(vNumNFE) = EmptyStr then begin
		result := false;
		exit;
	end;

	Tabelas.Inserir.Close;
	Tabelas.Inserir.SQL.Text := 'SELECT COUNT(*) as QTDE FROM NOTAFISCAL_CCE WHERE (Nr_Nota =:vNota OR Nr_Nota =:vNota2)';
	Tabelas.Inserir.Params[0].AsString:= vNumNFE;
	Tabelas.Inserir.Params[1].AsString:=FormatFloat('00000#', StrToFloat(vNumNFE));
	Tabelas.Inserir.Open;
	Tabelas.Inserir.First;
	if Tabelas.Inserir.FieldByName('QTDE').AsInteger > 0 then
		result := true
	else
		result := false;
end;

function AtualizarCustoPartsSeals(vCodProduto, vCodMaterial, vCustoMaterial : double):double;
begin
	Tabelas.Inserir.Close;
  Tabelas.Inserir.SQL.Text :=
    'SELECT a.ORDEM, PESO_UNIT ' +
    'FROM(SELECT p.ORDEM, ' +
    '            ((p.PS_EXTERNO_PRENS * p.PS_EXTERNO_PRENS * 0.785/100) - (p.PS_INTERNO_PRENS * p.PS_INTERNO_PRENS * 0.785/100))  * MA.PESO_ESPECIFICO * p.PS_ALTURA_PRENS / 1000/ 10 AS PESO_UNIT ' +
    '     FROM PRODUTOS p ' +
    '     INNER JOIN PS_INF_PROD MA ON MA.CODIGO = p.PS_ID_MATERIAL AND MA.TIPO = ''MA'' ' +
    '     WHERE MA.CODIGO  =:vCodMaterial ' +
    '    )a ' +
    'WHERE a.PESO_UNIT > 0 ';

  if vCodProduto > 0 then begin
    Tabelas.Inserir.SQL.Add(' AND a.ORDEM =:vOrdem ');
    Tabelas.Inserir.ParamByName('vOrdem').AsFloat := vCodProduto;
  end;

  Tabelas.Inserir.ParamByName('vCodMaterial').AsFloat := vCodMaterial;
  Tabelas.Inserir.Open;
  Tabelas.Inserir.First;

  if vCodProduto > 0 then begin
    //VAI RETORNAR O PESO DO PRODUTO ESPECIFICO
    result := Tabelas.Inserir.FieldByName('PESO_UNIT').AsFloat;
  end
  else begin

    {$REGION 'SET CUSTO'}
    Tabelas.Inserir.First;
    while not Tabelas.Inserir.Eof do begin
      Tabelas.Inserir3.Close;
      Tabelas.Inserir3.SQL.Text :=
        ' UPDATE PRODUTOS SET CUSTO = (:vPesoUnitario * :VCustoMaterial) WHERE ORDEM =:vOrdem ';

      Tabelas.Inserir3.ParamByName('vPesoUnitario').AsFloat  := Tabelas.Inserir.FieldByName('PESO_UNIT').AsFloat;
      Tabelas.Inserir3.ParamByName('VCustoMaterial').AsFloat := VCustoMaterial;
      Tabelas.Inserir3.ParamByName('vOrdem').AsFloat         := Tabelas.Inserir.FieldByName('ORDEM').AsFloat;
      Tabelas.Inserir3.ExecSQL;

      Tabelas.Inserir.Next;
    end;
    Tabelas.IBTrans.CommitRetaining;
    {$ENDREGION}

    {$REGION 'SET PREÇOS'}
    Tabelas.Inserir.First;
    while not Tabelas.Inserir.Eof do begin
      Tabelas.Inserir3.Close;
      Tabelas.Inserir3.SQL.Text :=
        'UPDATE  PRODUTOS SET ' +
        '  VISTA 	 = (CUSTO * (100 + MARCKUP) /100),  ' +
        '  ATACADO = (CUSTO * (100 + MARKUP_ATACADO) /100),  ' +
        '  PRECO3  = (CUSTO * (100 + MARKUP_PRECO3) /100), ' +
        '  PRECO4  = (CUSTO * (100 + MARKUP_PRECO4) /100) ' +
        'WHERE ORDEM =:vOrdem ';

      Tabelas.Inserir3.ParamByName('vOrdem').AsFloat := Tabelas.Inserir.FieldByName('ORDEM').AsFloat;
      Tabelas.Inserir3.ExecSQL;

      Tabelas.Inserir.Next;
    end;
    Tabelas.IBTrans.CommitRetaining;
    {$ENDREGION}

    //NAO VAI RETORNAR NADA POIS SÓ VAI ATUALIZAR EM MASSA
    result := 0;
  end;
end;


procedure VerificarEstornoCupomFiscal(cupom, nfe: integer; hora, sat_hora: ttime; seq_venda, chave_sat: string; sat_valor: double);
var vRetornoSAT :Integer;
vHora:TTime;
  vseqvenda: string;
begin
  //se for cupom fiscal
  Tabelas.tbConfig.Open;
  Tabelas.tbConfig2.Open;
  if (cupom > 0) then begin
    if not Tabelas.tbConfig.Active then
      Tabelas.tbConfig.Open;

    if not Tabelas.tbConfig2.Active then
      Tabelas.tbConfig2.Open;

    //se for ECF
    if Tabelas.tbConfigEcf.AsString = 'True' then begin
      Tabelas.Inserir5.Close;
      Tabelas.Inserir5.SQL.Text:='SELECT MAX(CUPOM) FROM MOVIMENTOS';
      Tabelas.Inserir5.Open;
      if (Tabelas.Inserir5.fields[0].AsInteger = cupom) then begin //se for o ultimo cancelar
        Menu1.ACBrECF.CancelaCupom;
      end else begin
        Application.MessageBox(PWideChar('ATENÇÃO!' + #13 + #13 + 'Existe Cupom Fiscal emitido p/ esta movimentação e o mesmo não foi cancelado.'),'Argus', mb_ok + mb_iconexclamation);
      end;
      Tabelas.Inserir5.Close;
    end;

    //SE FOR O SAT
    Tabelas.tbConfigLocal.Open;
    if (Tabelas.tbConfig2SAT_HABILITA.AsString = 'True') and (Tabelas.tbConfigLocalSAT_HABILITA_ESTACAO.AsString = 'True') then begin
      //verificar tempo da emissão
      vHora:= hora;
      if sat_hora > 0 then begin
        if TimeToStr(sat_hora) <> EmptyStr then
          vHora:=sat_hora;
      end;

      if (MinutesBetween(Time, vHora) > 30) then begin
        Application.MessageBox(PWideChar('ATENÇÃO!' + #13 + #13 + 'Existe Cupom Fiscal emitido p/ esta movimentação e o mesmo não foi cancelado.'),'Argus', mb_ok + mb_iconexclamation);
        RegistrarLOG('Movimentos', 'Estorno da Venda ' + seq_venda, '', 'Cupom Fiscal emitido e o mesmo não foi cancelado');
      end else begin //cancelar o sat
        vRetornoSAT:=Cancelar_Cfe_SAT(chave_sat);
        if (vRetornoSAT = 7000) then begin
          Tabelas.Inserir.Close;
          Tabelas.Inserir.SQL.Text:='UPDATE MOVIMENTOS SET SAT_CANCELADO=''True'', SAT_CHAVE_CANCELADO=:SAT_CHAVE_CANCELADO WHERE CHAVE_SAT=:CHAVE';
          Tabelas.Inserir.ParamByName('CHAVE').AsString:= chave_sat;
          Tabelas.Inserir.ParamByName('SAT_CHAVE_CANCELADO').AsString:= Menu1.ACBrSAT1.CFeCanc.infCFe.ID;
          Tabelas.Inserir.ExecSQL;

          Tabelas.Inserir.Close;
          Tabelas.Inserir.SQL.Text:='UPDATE MOVIMENTOS SET  OBS=:OBS, CUPOM=:CUPOM, SAT_VALOR=:SAT_VALOR WHERE CHAVE_SAT=:CHAVE AND TIPO LIKE :TIPO';
          Tabelas.Inserir.ParamByName('CHAVE').AsString:=chave_sat;
          Tabelas.Inserir.ParamByName('OBS').AsString:='Referente ao cupom ' + IntToStr(cupom);
          Tabelas.Inserir.ParamByName('CUPOM').AsInteger:=Menu1.ACBrSAT1.CFeCanc.ide.nCFe;
          Tabelas.Inserir.ParamByName('TIPO').AsString:='Devolução%';
          Tabelas.Inserir.ParamByName('SAT_VALOR').AsFloat:= sat_valor;
          Tabelas.Inserir.ExecSQL;

          Tabelas.IBTrans.CommitRetaining;
        end;
      end; //fim cancelar sat
    end; //fim se for o sat
  end;

  if (nfe > 0) then begin
    //verificar se a nota foi cancelada
    Tabelas.Inserir5.Close;
    Tabelas.Inserir5.SQL.Text:='SELECT * FROM NOTAFISCAL WHERE CANCELADA=''True'' AND NR_NOTA=:NOTA';
    Tabelas.Inserir5.ParamByName('NOTA').AsString:= IntToStr(nfe);
    Tabelas.Inserir5.Open;
    Tabelas.Inserir5.Last;
    if Tabelas.Inserir5.RecordCount = 0 then begin
      Application.MessageBox(PWideChar('ATENÇÃO!' + #13 + #13 + 'Existe NF-e emitida p/ esta movimentação e a mesma não foi cancelada.'),'Argus', mb_ok + mb_iconexclamation);
    end;
    Tabelas.Inserir5.Close;
  end;
end;

function TrocaTermo_Cheque_Pix(vComponente: TLabel; vTermo: String): Boolean;
begin
  if not Tabelas.tbConfig.Active then
    Tabelas.tbConfig.Open;

  if Tabelas.tbConfigBALCAO_TERMO_CHEQUE_PIX.AsString = 'True' then begin
    vComponente.Caption := vTermo;
    result := true;
  end
  else
    result := false;
end;

procedure GravarEtiqueta(ordem:double; descri, op:string;qtde :integer; TIPO:string);
begin
  Tabelas.Inserir.Close;
  Tabelas.Inserir.Sql.text:=
  'INSERT INTO TEMP1 (COD, DESCRI, DATA_EMBALAGEM, ORDEM_PRODUCAO, QTDE, UND) ' +
  'VALUES (:COD, :DESCRI, :DATA_EMBALAGEM, :ORDEM_PRODUCAO, :QTDE, :UND)';
  Tabelas.Inserir.ParamByName('COD').AsFloat:= ordem;
  Tabelas.Inserir.ParamByName('DESCRI').AsString:= Copy(descri,1,100);
  Tabelas.Inserir.ParamByName('DATA_EMBALAGEM').AsDateTime:=DATE;
  Tabelas.Inserir.ParamByName('ORDEM_PRODUCAO').AsString:=op;
  Tabelas.Inserir.ParamByName('QTDE').AsInteger:=qtde;
  Tabelas.Inserir.ParamByName('UND').AsString:=TIPO;
  Tabelas.Inserir.ExecSQL;
end;

function Retorna_CF_Pedido(vNum_Pedido: Double): Double;
begin
  Tabelas.Inserir.Close;
  Tabelas.Inserir.SQL.Text := 'SELECT SAT_CUPOM FROM PEDIDOS002 WHERE NUMERO = :NUMERO';
  Tabelas.Inserir.ParamByName('NUMERO').AsFloat := vNum_Pedido;
  Tabelas.Inserir.Open;
  Tabelas.Inserir.First;
  Result := Tabelas.Inserir.FieldByName('SAT_CUPOM').AsFloat;
end;

function Existe_Transferencia_Entre_Contas(vCont: Double):boolean;
begin
  Tabelas.Inserir.Close;
  Tabelas.Inserir.SQL.Text := 'SELECT COUNT(CONT) AS QTDE FROM BANCO WHERE CONT_TRANSFERENCIA = :PARAM';
  Tabelas.Inserir.Params[0].AsFloat := vCont;
  Tabelas.Inserir.Open;
  Tabelas.Inserir.Last;
  if Tabelas.Inserir.FieldByName('QTDE').AsFloat > 0 then
    Result := true
  else
    Result := false;
end;

function VerificaMultiEmpresa:boolean;
begin
  if not Tabelas.tbConfig.Active then
    Tabelas.tbConfig.Open;

  if (Tabelas.tbConfigMLT_EMP.AsString = 'True') then
    Result := True
  else
    Result := False;
end;

function SegundosToTime( Segundos : Cardinal ) : String;
var Seg, Min, Hora: Cardinal;
begin
  Hora := Segundos div 3600;
  Seg := Segundos mod 3600;
  Min := Seg div 60;
  Seg := Seg mod 60;
  Result := FormatFloat(',00', Hora) + ':' +
  FormatFloat('00', Min) + ':' +
  FormatFloat('00', Seg);
end;

procedure AlterarCaptionTitleDBGrid(vCaption, vFieldColuna: String; vGrid: TDBGrid);
var
  i: integer;
begin
  for i:=0 to vGrid.Columns.Count-1 do begin
    if UpperCase(vGrid.Columns[i].FieldName) = UpperCase(vFieldColuna) then begin
      vGrid.Columns[i].Title.Caption := vCaption;
    end;
  end;
end;

procedure AlterarFieldDBGrid(vField_Antigo, vField_Novo: String; vGrid: TDBGrid);
var
  i: integer;
begin
  for i:=0 to vGrid.Columns.Count-1 do begin
    if UpperCase(vGrid.Columns[i].FieldName) = UpperCase(vField_Antigo) then begin
      vGrid.Columns[i].FieldName := vField_Novo;
    end;
  end;
end;

procedure DimensionarGrid(dbg: TDBGrid);
type
  TArray = Array of Integer;
  procedure AjustarColumns(Swidth, TSize: Integer; Asize: TArray);
  var
    idx: Integer;
  begin
    if TSize = 0 then
    begin
      TSize := dbg.Columns.count;
      for idx := 0 to dbg.Columns.count - 1 do
        dbg.Columns[idx].Width := (dbg.Width - dbg.Canvas.TextWidth('AAAAAA')
          ) div TSize
    end
    else
      for idx := 0 to dbg.Columns.count - 1 do
        dbg.Columns[idx].Width := dbg.Columns[idx].Width +
          (Swidth * Asize[idx] div TSize);
  end;

var
  idx, Twidth, TSize, Swidth: Integer;
  AWidth: TArray;
  Asize: TArray;
  NomeColuna: String;
begin
  SetLength(AWidth, dbg.Columns.count);
  SetLength(Asize, dbg.Columns.count);
  Twidth := 0;
  TSize := 0;
  for idx := 0 to dbg.Columns.count - 1 do
  begin
    NomeColuna := dbg.Columns[idx].Title.Caption;
    dbg.Columns[idx].Width := dbg.Canvas.TextWidth
      (dbg.Columns[idx].Title.Caption + 'A');
    AWidth[idx] := dbg.Columns[idx].Width;
    Twidth := Twidth + AWidth[idx];

    if Assigned(dbg.Columns[idx].Field) then
      Asize[idx] := dbg.Columns[idx].Field.Size
    else
      Asize[idx] := 1;

    TSize := TSize + Asize[idx];
  end;
  if TDBGridOption.dgColLines in dbg.Options then
    Twidth := Twidth + dbg.Columns.count;

  // adiciona a largura da coluna indicada do cursor
  if TDBGridOption.dgIndicator in dbg.Options then
    Twidth := Twidth + IndicatorWidth;

  Swidth := dbg.ClientWidth - Twidth;
  AjustarColumns(Swidth, TSize, Asize);
end;

function VerificaControle_Abertura(vRotina, vChave_Serial: String; vNumero: Integer):String;
begin
  Tabelas.Inserir.Close;
  Tabelas.Inserir.SQL.Text := 'SELECT NOME_COMPUTADOR FROM ACESSO_SIMUL WHERE ROTINA=:ROTINA AND NUMERO=:NUMERO';
  Tabelas.Inserir.ParamByName('ROTINA').AsString := vRotina;
  Tabelas.Inserir.ParamByName('NUMERO').AsInteger := vNumero;
  Tabelas.Inserir.Open;

  Result := Tabelas.Inserir.Fields[0].AsString;
end;

procedure AtualizaControle_Abertura(vRotina, vChave_Serial, vOperacao: String; vNumero: Integer);
begin
  Tabelas.Inserir.Close;

  if vOperacao = 'ENTRADA' then begin
    Tabelas.Inserir.SQL.Text := 'INSERT INTO ACESSO_SIMUL (ROTINA, CHAVE_SERIAL, NUMERO, NOME_COMPUTADOR) VALUES (:ROTINA, :CHAVE_SERIAL, :NUMERO, :NOME_COMPUTADOR)';
    Tabelas.Inserir.ParamByName('NOME_COMPUTADOR').AsString := getNomeComputador;
  end
  else if vOperacao = 'SAIDA' then
    Tabelas.Inserir.SQL.Text := 'DELETE FROM ACESSO_SIMUL WHERE ROTINA=:ROTINA AND CHAVE_SERIAL=:CHAVE_SERIAL AND NUMERO=:NUMERO';

  Tabelas.Inserir.ParamByName('ROTINA').AsString := vRotina;
  Tabelas.Inserir.ParamByName('CHAVE_SERIAL').AsString := vChave_Serial;
  Tabelas.Inserir.ParamByName('NUMERO').AsInteger := vNumero;

  Tabelas.Inserir.ExecSQL;
  Tabelas.IBTrans.CommitRetaining;
end;

procedure LimparAcesso_Simul(vChave_Serial: String);
begin
  Tabelas.Inserir.Close;
  Tabelas.Inserir.SQL.Text := 'DELETE FROM ACESSO_SIMUL WHERE CHAVE_SERIAL=:CHAVE';
  Tabelas.Inserir.Params[0].AsString := vChave_Serial;
  Tabelas.Inserir.ExecSQL;
  Tabelas.IBTrans.CommitRetaining;
end;

Function GerarSerialNum(FDrive: String): String;
Var
  Serial: DWord;
  DirLen, Flags: DWord;
  DLabel: Array [0 .. 11] of Char;
begin
  Try
    GetVolumeInformation(pchar(FDrive + ':\'), DLabel, 12, @Serial, DirLen,
      Flags, nil, 0);
    Result := IntToHex(Serial, 10);
  Except Result := '';
  end;
end;

Function GetWindowsDrive: Char;
var
  S: string;
begin
  SetLength(S, MAX_PATH);
  if GetWindowsDirectory(pchar(S), MAX_PATH) > 0 then Result := string(S)[1]
  else Result := #0;
end;

function ObterVersaoWindows: String;
var
  vNome,
  vVersao,
  vCurrentBuild: String;
  Reg: TRegistry;
begin
  Reg         := TRegistry.Create; //Criando um Registro na Memória
  Reg.Access  := KEY_READ; //Colocando nosso Registro em modo Leitura
  Reg.RootKey := HKEY_LOCAL_MACHINE; //Definindo a Raiz

  //Abrindo a chave desejada
  Reg.OpenKey('\SOFTWARE\Microsoft\Windows NT\CurrentVersion\', true);

  //Obtendo os Parâmetros desejados
  vNome         := Reg.ReadString('ProductName');
  vVersao       := Reg.ReadString('CurrentVersion');
  vCurrentBuild := Reg.ReadString('CurrentBuild');

  //Montando uma String com a Versão e alguns detalhes
  Result := vNome + ' - ' + vVersao + ' - ' + vCurrentBuild;
end;

function flMessage(flMessage: String; fTitulo: String; flType: TMsgDlgType; flbutton: TMsgDlgButtons;
  flColor: TColor; flBold, flItalic: boolean; flFonte: TFontName): Integer;
var
  MsgFont: TFont;
begin

  with CreateMessageDialog(flMessage, flType, flbutton) do
    try
      MsgFont := TLabel(FindComponent('Message')).Font;
      MsgFont.Color := flColor;
      MsgFont.Name := flFonte;
      Caption := fTitulo;

      if flBold then
        MsgFont.Style := MsgFont.Style + [fsBold];
      if flItalic then
        MsgFont.Style := MsgFont.Style + [fsItalic];

      Result := ShowModal;
    finally
      Free;
    end;
end;

procedure CriarQry;
begin
  qryX:=TIBQuery.Create(nil);
  qryX.Database:=Tabelas.Conexao;
  qryX.Transaction:=Tabelas.IBTrans;
end;

function MontaEnderecosCli(vCodCli, CodigoContato, vIndice: integer):TEnderecosCliente;
var Enderecos: TEnderecosCliente;
begin
  if vcodCli <> 0 then begin
    Enderecos.Endereco := ('Endereço ' + IntToStr(vIndice));
    Enderecos.Objeto := TObject(Integer(CodigoContato));
    Result := Enderecos;
  end;
end;

procedure ExcluiRegistro(vTabela, vCampo, vIndice: String);
begin
  CriarQry;
  qryX.Close;
  Try
    qryX.SQL.Text := 'DELETE FROM ' + vTabela + ' WHERE ' + vCampo + ' = ' + vIndice ;
    qryX.ExecSQL;
    Tabelas.IBTrans.CommitRetaining;
  Except on E:Exception do
    begin
      Application.MessageBox('ATENÇÃO' + #13 + 'Ocorreu um erro ao executar esta operação','Argus',MB_OK+MB_ICONERROR);
    end;
  End;
  FreeAndNil(qryx);
end;

procedure HabilitaCapsLock;
var
  KeyState: TKeyboardState;
begin
  GetKeyboardState(KeyState);
  if(KeyState[VK_CAPITAL] = 0) then begin

      Keybd_Event(VK_CAPITAL, 1, KEYEVENTF_EXTENDEDKEY or 0, 0);
      Keybd_Event(VK_CAPITAL, 1, KEYEVENTF_EXTENDEDKEY or KEYEVENTF_KEYUP, 0);
  end;
end;

procedure CarregaPickListGrid(Campo, Tabela: String; GRID: TDBGrid; vNumColunaGrid: Integer);
var slPickList :TStringList;
begin
  slPickList:=TStringList.Create;
  slPickList.Clear;
  Tabelas.Inserir.close;
  Tabelas.Inserir.SQL.Text := 'SELECT ' + CAMPO + ' FROM ' + TABELA;
  Tabelas.Inserir.Open;
  Tabelas.Inserir.First;

  while not Tabelas.Inserir.Eof do begin
    slPickList.Add(Tabelas.Inserir.FieldByName(CAMPO).AsString);
    Tabelas.Inserir.Next;
  end;

  Tabelas.Inserir.Close;
  GRID.Columns[vNumColunaGrid].PickList:=slPickList;
  slPickList.Free;
end;

Function getNomeComputador: String;
var
  Computer: array [ 0 .. 256] of char;
  CSize: DWord;
begin
{  CSize := MAX_COMPUTERNAME_LENGTH + 1;
  try
    GetMem(Computer, CSize);
    if GetComputerName(Computer, CSize) then Result := Computer
    else Result := '';
  except Result := '';
  end;}

  CSize:=256;
  try
    if GetComputerName(Computer, CSize) then
      Result:=Computer
    else
      Result:='';
  except
    Result:='';
  end;
end;


procedure AbrirDetalheOrdemProducao(sOrdem:double);
begin
  Application.CreateForm(TFMemo, FMemo);
  tabelas.Inserir3.Close;
  tabelas.Inserir3.SQL.Text:='select s.numero, s.qtde, o.cliente from ordemprod_sub s inner join ordemprod o on o.numero=s.numero ' +
  'where s.codigo=:ordem and (o.FINALIZADO is null or o.FINALIZADO =''False'' ) order by s.numero';
  tabelas.Inserir3.ParamByName('ordem').Asfloat:=sOrdem;
  tabelas.Inserir3.Open;
  FMemo.C_Memo.Lines.Clear;

  tabelas.Inserir5.Close;
  tabelas.Inserir5.SQL.Text:='SELECT SUM(QTDE) FROM PEDIDOS001 WHERE ORDEM=:O';
  tabelas.Inserir5.ParamByName('O').AsFloat:=sOrdem;
  tabelas.Inserir5.Open;
  FMemo.C_Memo.Lines.Add('Total Venda : ' + formatfloat(tabelas.tbProdutos1ESTOQUE.DisplayFormat, tabelas.Inserir5.Fields[0].AsFloat));
  tabelas.Inserir5.Close;
  FMemo.C_Memo.Lines.Add('');
  tabelas.Inserir3.First;
  while not tabelas.Inserir3.Eof do begin
    FMemo.C_Memo.Lines.Add('Ordem de Produção: ' + tabelas.Inserir3.FieldByName('NUMERO').AsString);
    FMemo.C_Memo.Lines.Add('Qtde: ' + formatfloat(tabelas.tbProdutos1ESTOQUE.DisplayFormat, tabelas.Inserir3.FieldByName('QTDE').AsFloat));
    FMemo.C_Memo.Lines.Add('Cliente: ' + tabelas.Inserir3.FieldByName('CLIENTE').AsString);
    FMemo.C_Memo.Lines.Add('');
    tabelas.Inserir3.Next;
  end;
  tabelas.Inserir3.Close;

  FMemo.ShowModal;
  FreeAndnil(FMemo);
end;

function PegaMes(mes:integer):string;
  begin
    if mes=1 then Result:='Janeiro';
    if mes=2 then Result:='Fevereiro';
    if mes=3 then Result:='Março';
    if mes=4 then Result:='Abril';
    if mes=5 then Result:='Maio';
    if mes=6 then Result:='Junho';
    if mes=7 then Result:='Julho';
    if mes=8 then Result:='Agosto';
    if mes=9 then Result:='Setembro';
    if mes=10 then Result:='Outubro';
    if mes=11 then Result:='Novembro';
    if mes=12 then Result:='Dezembro';
  end;

function TerminarProcesso(sFile: String): Boolean;
var verSystem: TOSVersionInfo;
    hdlSnap,hdlProcess: THandle;
    bPath,bLoop: Bool;
    peEntry: TProcessEntry32;
    arrPid: Array [0..1023] of DWORD;
    iC: DWord;
    k,iCount: Integer;
    arrModul: Array [0..299] of Char;
    hdlModul: HMODULE;
begin
  Result := False;
  if ExtractFileName(sFile)=sFile then
    bPath:=false
  else
    bPath:=true;
  verSystem.dwOSVersionInfoSize:=SizeOf(TOSVersionInfo);
  GetVersionEx(verSystem);
  if verSystem.dwPlatformId=VER_PLATFORM_WIN32_WINDOWS then begin
    hdlSnap:=CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    peEntry.dwSize:=Sizeof(peEntry);
    bLoop:=Process32First(hdlSnap,peEntry);
    while integer(bLoop)<>0 do begin
      if bPath then begin
        if CompareText(peEntry.szExeFile,sFile) = 0 then begin
          TerminateProcess(OpenProcess(PROCESS_TERMINATE,false,peEntry.th32ProcessID), 0);
          Result := True;
        end;
      end else begin
        if CompareText(ExtractFileName(peEntry.szExeFile),sFile) = 0 then begin
          TerminateProcess(OpenProcess(PROCESS_TERMINATE,false,peEntry.th32ProcessID), 0);
          Result := True;
        end;
      end;
      bLoop := Process32Next(hdlSnap,peEntry);
    end;
    CloseHandle(hdlSnap);
  end else
    if verSystem.dwPlatformId=VER_PLATFORM_WIN32_NT then begin
      EnumProcesses(@arrPid,SizeOf(arrPid),iC);
      iCount := iC div SizeOf(DWORD);
      for k := 0 to Pred(iCount) do begin
        hdlProcess:=OpenProcess(PROCESS_QUERY_INFORMATION or PROCESS_VM_READ,false,arrPid [k]);
        if (hdlProcess<>0) then begin
          EnumProcessModules(hdlProcess,@hdlModul,SizeOf(hdlModul),iC);
          GetModuleFilenameEx(hdlProcess,hdlModul,arrModul,SizeOf(arrModul));
          if bPath then begin
            if CompareText(arrModul,sFile) = 0 then begin
              TerminateProcess(OpenProcess(PROCESS_TERMINATE or PROCESS_QUERY_INFORMATION,False,arrPid [k]), 0);
              Result := True;
            end;
          end else begin
            if CompareText(ExtractFileName(arrModul),sFile) = 0 then begin
              TerminateProcess(OpenProcess(PROCESS_TERMINATE or PROCESS_QUERY_INFORMATION,False,arrPid [k]), 0);
              Result := True;
            end;
          end;
          CloseHandle(hdlProcess);
        end;
      end;
    end;
end;

function VerificaSePodeBaixarPedido(ds:TIBTable):boolean;
var res:boolean;
begin
  ds.First;
  res:=true;
  while not ds.Eof do begin
    tabelas.Inserir.Close;
    tabelas.Inserir.SQL.Text:='SELECT ESTOQUE, DESCRICAO FROM PRODUTOS WHERE ORDEM=:O';
    tabelas.Inserir.ParamByName('O').AsFloat:=DS.FieldByName('ORDEM').AsFloat;
    tabelas.Inserir.Open;
    if tabelas.Inserir.FieldByName('DESCRICAO').AsString <> '' then begin
      if ds.FieldByName('QTDE').AsFloat > TABELAS.Inserir.FieldByName('ESTOQUE').AsFloat then begin
        res:=FALSE;
        if (ds = tabelas.TablePedidos001) then begin
          ds.Edit;
          ds.FieldByName('COTA_TEMP_SUP').AsFloat:=1;
          ds.Post;
        end;
      end;
    end;

    ds.Next;
  end;
  if (ds = tabelas.TablePedidos001) then
    tabelas.IBTrans.CommitRetaining;

  Result:=res;
end;

function VerificaColunaVisivel(vCampo:string; Grid: TDBGrid):Boolean;
var i:integer;
    Visivel:boolean;
begin
  Visivel:=False;
  for i:=1 to Grid.Columns.Count do begin
    if (Grid.Columns[i-1].FieldName = vCampo) then
      Visivel:=Grid.Columns[i-1].Visible;
  end;
  Result:=Visivel;
end;

function CustoMedio_AtacadoBetel(sOrdem, sCusto:double):double;
begin
  Tabelas.Inserir3.Close;
  Tabelas.Inserir3.SQL.Text:='select first 1 unitario from movientrasub where ordem=:ordem order by numero desc';
  Tabelas.Inserir3.ParamByName('ordem').AsFloat:=sOrdem;
  Tabelas.Inserir3.Open;
  Result:=(Tabelas.Inserir3.Fields[0].AsFloat + sCusto) / 2;
  Tabelas.Inserir3.Close;
end;


Procedure SetGridVisivel(Grid:TDBGrid;vCampo:string; Visivel: Boolean);
var i:integer;
begin
  for i:=1 to Grid.Columns.Count do begin
    if (Grid.Columns[i-1].FieldName = vCampo) then
      Grid.Columns[i-1].Visible := Visivel;
  end;
end;


function OS_Excluida(sOS:double):boolean;
begin
  tabelas.Inserir3.Close;
  tabelas.Inserir3.SQL.Text:='SELECT COUNT(*) FROM ORC WHERE NUMERO=:N';
  tabelas.Inserir3.ParamByName('N').AsFloat:=sOS;
  tabelas.Inserir3.Open;
  if tabelas.Inserir3.Fields[0].AsInteger = 0 then begin

    tabelas.Inserir3.Close;
    tabelas.Inserir3.SQL.Text:='SELECT USUARIO FROM LOG_ARGUS WHERE TABELA=''Ordem Serviço'' and TIPO=''Exclusão'' and CODIGO=:C';
    tabelas.Inserir3.ParamByName('C').AsString:=floattostr(sOS);
    tabelas.Inserir3.Open;
    Application.MessageBox(pchar('Essa Ordem de Serviço ja foi excluída pelo usuário ' + tabelas.Inserir3.Fields[0].AsString + #13 + 'Cancele a operação.'), 'Atenção', mb_ok + mb_iconerror);
    tabelas.Inserir3.Close;

    Result:=true;
  end else begin
    tabelas.Inserir3.Close;
    Result:=false;
  end;
end;

procedure Verificar_Estoque_TableVendas(scampoest:string);
begin
  Tabelas.IBTransTemp.CommitRetaining;
  tabelas.Inserir2.Close;
  tabelas.Inserir2.SQL.Text:='SELECT SUM(QTDE) AS QTDE, ORDEM FROM VENDAS GROUP BY ORDEM';
  tabelas.Inserir2.Open;
  tabelas.Inserir2.First;
  while not tabelas.Inserir2.Eof do begin
    if (Tabelas.Inserir2.FieldByName('ORDEM').AsString <> '99999') then begin
      tabelas.Inserir.Close;
      tabelas.Inserir.SQL.Text:='SELECT ' + scampoest +', DESCRICAO FROM PRODUTOS WHERE ORDEM=:O';
      tabelas.Inserir.ParamByName('O').AsFloat:=tabelas.Inserir2.FieldByName('ORDEM').AsFloat;
      tabelas.Inserir.Open;
      if (tabelas.Inserir.FieldByName(scampoest).AsFloat < tabelas.Inserir2.FieldByName('QTDE').AsFloat) then begin
        Application.MessageBox(pchar('ATENÇÃO! - Estoque insuficiente' + #13 + #13 + tabelas.Inserir.FieldByName('DESCRICAO').AsString), 'Argus', mb_ok + mb_iconexclamation);
        Abort;
      end;
    end;
    tabelas.Inserir2.Next;
  end;
  tabelas.Inserir2.Close;
end;

function ConverteBoolean(Campo :String) : Boolean;
begin
  if (Campo = 'True') OR (Campo = 'T') OR (Campo = 'S') then
    Result:=True
  else
    Result:=False;
end;

function Ultimo_NossoNrNovo(sBanco, sBancoDescri:string):string;
var vCon :TIBDatabase;
vTrans:TIBTransaction;
vqry:TIBQuery;
vIbtable:TIBTable;
vTemp:String;
begin
  vCon:=TIBDatabase.Create(nil);
  vCon.DatabaseName:=tabelas.Conexao.DatabaseName;
  vCon.SQLDialect:=tabelas.Conexao.SQLDialect;
  vCon.Params:=tabelas.Conexao.Params;
  vCon.LoginPrompt:=false;

  vTrans:=TIBTransaction.Create(nil);
  vTrans.Params:=tabelas.IBTrans.Params;
  vTrans.DefaultDatabase:=vCon;


  vCon.DefaultTransaction:=vTrans;

  vCon.Connected:=true;
  vTrans.Active:=true;

  vqry:=TIBQuery.Create(nil);
  vqry.Database:=vCon;
  vqry.Transaction:=vTrans;

  vqry.Close;
  vqry.SQL.Text:='SELECT MAX(CAST(BOL_NOSSONR AS BIGINT)) FROM PEDIDOS_MOVI WHERE ' +
  'BANCO_DESCRICAO = :vDescri AND (Bol_NossoNr IS NOT NULL and BOL_NOSSONR <> '''') AND TIPO CONTAINING(''BOLETO'')';
  vqry.ParamByName('vDescri').AsString:=sBancoDescri;
  vqry.Open;
  vTemp:=Copy(vqry.Fields[0].AsString,8,15);

  if (sBanco = 'Itaú') or (sBanco = 'Sicredi') or (sBanco = 'Sicoob') or (sBanco = 'Santander') or (sBanco = 'Safra') then
    vTemp:=vqry.Fields[0].AsString;

  //tratamento erro boleto dguida 03/04/19
  if (sBanco = 'Santander') and (Menu1.vCodigo_Cliente_Config = '319') then begin
    vIbtable:=TIBTable.Create(nil);
    vIbtable.Database:=vCon;
    vIbtable.Transaction:=vTrans;
    vIbtable.TableName:='CONFIGBOL';
    vIbtable.Open;
    vIbtable.Locate('DESCRICAO_CONTA', sBancoDescri, []);
    if (Pos(vIbtable.FieldByName('CONVENIO').AsString, vTemp) > 0) or (Pos(vIbtable.FieldByName('CONVENIO').AsString, vIbtable.FieldByName('NOSSO_NR').AsString) > 0) then begin
      vTemp:=StringReplace(vTemp, vIbtable.FieldByName('CONVENIO').AsString, '', []);
      vIbtable.Edit;
      vIbtable.FieldByName('NOSSO_NR').AsString:=StringReplace(vIbtable.FieldByName('NOSSO_NR').AsString, vIbtable.FieldByName('CONVENIO').AsString, '', []);
      vIbtable.Post;
      vTrans.CommitRetaining;
    end;
    vIbtable.Close;
    freeandnil(vIbtable);
  end;
  //fim

  if (vTemp = '') then vTemp:='0';

  vqry.Close;
  vTrans.Active:=false;
  vCon.Connected:=false;
  Freeandnil(vqry);
  Freeandnil(vTrans);
  Freeandnil(vCon);
  Result:=vTemp;
end;

function Ultimo_NossoNr(sBanco, sBancoDescri:String):string;
var vTemp:String;
begin
  try
    tabelas.IBTrans.CommitRetaining;
  except
  end;
  Tabelas.Inserir5.Close;
  Tabelas.Inserir5.SQL.Text:='SELECT MAX(CAST(BOL_NOSSONR AS BIGINT)) FROM PEDIDOS_MOVI WHERE ' +
  'BANCO_DESCRICAO = :vDescri AND (Bol_NossoNr IS NOT NULL and BOL_NOSSONR <> '''') AND TIPO CONTAINING(''BOLETO'')';
  Tabelas.Inserir5.ParamByName('vDescri').AsString:=sBancoDescri;
  Tabelas.Inserir5.Open;
  vTemp:=Copy(Tabelas.Inserir5.Fields[0].AsString,8,15);

  if (sBanco = 'Itaú') or (sBanco = 'Sicredi') or (sBanco = 'Sicoob') or (sBanco = 'Santander') or (sBanco = 'Safra') then
    vTemp:=Tabelas.Inserir5.Fields[0].AsString;

  //tratamento erro boleto dguida 03/04/19
  if (sBanco = 'Santander') and (Menu1.vCodigo_Cliente_Config = '319') then begin
    if not tabelas.tbConfigBol.Active then tabelas.tbConfigBol.Open;
    tabelas.tbConfigBol.Locate('DESCRICAO_CONTA', sBancoDescri, []);
    if (Pos(tabelas.tbConfigBolCONVENIO.AsString, vTemp) > 0) or (Pos(tabelas.tbConfigBolCONVENIO.AsString, tabelas.tbConfigBolNOSSO_NR.AsString) > 0) then begin
      vTemp:=StringReplace(vTemp, tabelas.tbConfigBolCONVENIO.AsString, '', []);
      tabelas.tbConfigBol.Edit;
      tabelas.tbConfigBolNOSSO_NR.AsString:=StringReplace(tabelas.tbConfigBolNOSSO_NR.AsString, tabelas.tbConfigBolCONVENIO.AsString, '', []);
      tabelas.tbConfigBol.Post;
      tabelas.IBTrans.CommitRetaining;
      tabelas.tbConfigBol.Close;
      tabelas.tbConfigBol.Open;
      tabelas.tbConfigBol.Locate('DESCRICAO_CONTA', sBancoDescri, []);
    end;
  end;
  //fim

  if (vTemp = '') then vTemp:='0';
  Tabelas.Inserir5.Close;
  Result:=vTemp;
end;

function Verifica_Impressora:boolean;
begin
  try
    if (Printer.PrinterIndex >= 0) then
      Result:=true
    else
      Result:=false;
  except
    Result:=false;
  end;
end;

function SugestaoUCAF(sOrdem:double; sMes:integer):integer;
var vQtde:double;
vRes, vDias, sEst, sEstMin, vReservado:integer;
begin
 { vReservado:=trunc(EstoqueReservado(FloatToStr(sOrdem), '0'));
  //pegar o mes do cadastro de grupo 20/03/19
  tabelas.Inserir5.Close;
  tabelas.Inserir5.SQL.Text:='SELECT P.ORDEM, G.MESES, P.ESTOQUE, P.ESTOQUEMINIMO FROM PRODUTOS AS P INNER JOIN GRUPOS AS G ON G.NOMEGRUPO=P.NOMEGRUPO WHERE ' +
  'P.ORDEM=:O';
  tabelas.Inserir5.ParamByName('O').AsFloat:=sOrdem;
  tabelas.Inserir5.Open;
  sMes:=tabelas.Inserir5.FieldByName('MESES').AsInteger;
  sEst:=tabelas.Inserir5.FieldByName('ESTOQUE').AsInteger;
  sEstMin:=tabelas.Inserir5.FieldByName('ESTOQUEMINIMO').AsInteger;

 // sMes:=sMes * 2; 27/02/20
  vDias  := sMes * 30;

  if vDias = 0 then vDias:=30;

  tabelas.Inserir5.Close;
  tabelas.Inserir5.SQL.Text:='SELECT SUM(P1.QTDE) AS QTDE FROM PEDIDOS001 AS P1 INNER JOIN PEDIDOS002 AS P2 ' +
  'ON P2.NUMERO=P1.NUMERO WHERE P1.ORDEM=:O AND P2.DATA BETWEEN :DATA1 AND :DATA2';
  tabelas.Inserir5.ParamByName('DATA1').AsDateTime := incday(date, - vDias);
  tabelas.Inserir5.ParamByName('DATA2').AsDateTime:=DATE;
  tabelas.Inserir5.ParamByName('O').AsFloat:=sOrdem;
  tabelas.Inserir5.Open;
  vQtde:=tabelas.Inserir5.Fields[0].AsFloat;
  tabelas.Inserir5.Close;

  vRes:= Trunc(vQtde/2);

  vRes:=vRes + sEstMin - sEst; //27/02/20
  if (vReservado > (vRes + sEst)) then       ///27/02/20
    vRes:= vRes + (vReservado - (vRes + sEst));    //27/02/20

  if vRes < 0 then
    vRes:=0;    }//09/03/20

  //pegar o mes do cadastro de grupo 20/03/19
  tabelas.Inserir5.Close;
  tabelas.Inserir5.SQL.Text:='SELECT P.ORDEM, G.MESES, P.ESTOQUE, P.ESTOQUEMINIMO FROM PRODUTOS AS P INNER JOIN GRUPOS AS G ON G.NOMEGRUPO=P.NOMEGRUPO WHERE P.ORDEM=:O';
  tabelas.Inserir5.ParamByName('O').AsFloat:=sOrdem;
  tabelas.Inserir5.Open;
  sMes:=tabelas.Inserir5.FieldByName('MESES').AsInteger;
  if sMes = 0 then
    sMes:=3;

  tabelas.Inserir5.Close;
  tabelas.Inserir5.SQL.Text:='SELECT SUM(P1.QTDE) AS QTDE FROM PEDIDOS001 AS P1 INNER JOIN PEDIDOS002 AS P2 ' +
  'ON P2.NUMERO=P1.NUMERO WHERE P1.ORDEM=:O AND P2.DATA BETWEEN :DATA1 AND :DATA2';
  tabelas.Inserir5.ParamByName('DATA1').AsDateTime := IncYear(date, -1);
  tabelas.Inserir5.ParamByName('DATA2').AsDateTime:=DATE;
  tabelas.Inserir5.ParamByName('O').AsFloat:=sOrdem;
  tabelas.Inserir5.Open;
  vQtde:=Round(tabelas.Inserir5.Fields[0].AsInteger / 12);
  vRes:= Round(vQtde * sMes);
  result:=vRes;
end;

function EstoqueReservado(sOrdem, sPed:String):double;
begin
  tabelas.Inserir5.Close;
  {tabelas.Inserir5.SQL.Text:='SELECT SUM(P1.QTDE) AS QTDE FROM PEDIDOS001 AS P1 INNER JOIN PEDIDOS002 AS P2 ' +
  'ON P2.NUMERO=P1.NUMERO WHERE P1.ORDEM=:O AND (P2.NR_NF IS NULL OR P2.NR_NF=0) AND P2.NUMERO <> :NUM' ;
  tabelas.Inserir5.ParamByName('NUM').AsString:=sPed;
   }//17/02/20

  tabelas.Inserir5.SQL.Text:='SELECT SUM(p1.QTDE) FROM PEDIDOS001 p1 inner join pedidos002 p2 on p2.numero=p1.numero ' +
  ' WHERE p1.ORDEM=:O AND (p1.NR_NOTA IS NULL OR p1.NR_NOTA =0) and (p2.baixado = ''Não'')';
  tabelas.Inserir5.ParamByName('O').AsString:=sOrdem;
  tabelas.Inserir5.Open;
  result:= strtofloat(Formatfloat(tabelas.tbProdutos1ESTOQUE.DisplayFormat, tabelas.Inserir5.Fields[0].asfloat));
end;

function SaldoEstoqueUCAF(sOrdem:string; sEst, sQtde:double):boolean;
  function RetornaQtde(sOrdem:string):double;
  begin
    tabelas.Inserir.Close;
    tabelas.Inserir.SQL.Text:='SELECT SUM(QTDE) FROM UCAF_ORDEMPROD_MOV WHERE ' +
    'ORDEM=:O AND VINC IS NULL AND RETRABALHO = ''N'' ';
    tabelas.Inserir.ParamByName('O').AsString:=sOrdem;
    tabelas.Inserir.Open;
    Result:=tabelas.Inserir.Fields[0].AsFloat;
    tabelas.Inserir.Close;
  end;
var vSaldo, vtemp_retorna_qtde:double;
begin
  vtemp_retorna_qtde:=RetornaQtde(sOrdem);
  //22/03/22 vSaldo:=sEst - EstoqueReservado(sOrdem, '0') + vtemp_retorna_qtde - sQtde;
  vSaldo:=sEst - EstoqueReservado(sOrdem, '0') - sQtde;
  if vSaldo < 0 then begin
    Application.MessageBox('Este item deve ser produzido!','Atenção', mb_ok + mb_iconinformation);
    Result:=false;
  end else begin
    Result:=true;
    {
    if vtemp_retorna_qtde > 0 then
      Result:=true
    else
      Result:=false;
      }
  end;
end;

function EstoqueAtual(sOrdem:String):double;
begin
  tabelas.Inserir5.Close;
  tabelas.Inserir5.SQL.Text:='SELECT ESTOQUE FROM PRODUTOS WHERE ORDEM=:O';
  tabelas.Inserir5.ParamByName('O').AsString:=sOrdem;
  tabelas.Inserir5.Open;
  result:= strtofloat(Formatfloat(tabelas.tbProdutos1ESTOQUE.DisplayFormat, tabelas.Inserir5.Fields[0].asfloat));
end;

function EstoqueEmProducao(sOrdem:double):integer;
begin
  tabelas.Inserir5.Close;
  tabelas.Inserir5.SQL.Text:='select sum(m.qtde) qtde from UCAF_ORDEMPROD_MOV as M where (M.tipo=''PRODUCAO'' OR M.TIPO=''FILA'') ' +
  ' AND M.VINC IS NULL and m.ordem=:ordem AND M.RETRABALHO=''N''';
  tabelas.Inserir5.ParamByName('ordem').AsFloat:=sOrdem;
  tabelas.Inserir5.Open;
  result:=tabelas.Inserir5.Fields[0].AsInteger;
  tabelas.Inserir5.Close;
end;


function TiraPonto(sCampo:String):double;
begin
  if sCampo <> '' then
    result:=strtofloat(StringReplace(sCampo, '.', '', []))
  else
    result:=0;
end;

function Procurar_Arq_Pasta(sPasta, sParteNome :string):String;
var SearchRec: TSearchRec;
begin
  if sPasta[length(sPasta)] <> '' then  sPasta:= sPasta + '';
  SetCurrentDir(sPasta);

  if FindFirst(sParteNome, faAnyFile, SearchRec) = 0 then
    Repeat
  Result :=SearchRec.Name;
  Until FindNext(SearchRec) <> 0;
  FindClose(SearchRec);
end;

procedure AbrirArquivo(sCampo:String);
var handle:THandle;
begin
  if sCampo <> '' then begin
    try
      ShellExecute(handle, nil, pchar(sCampo) , nil, nil, SW_SHOWNORMAL);
    except
      on e:exception do begin
        Application.MessageBox(pchar('Erro ao visualizar o arquivo.' + #13 +
        'Verifique se o arquivo encontra-se no local informado.' + #13 + #13 + e.Message), 'Argus', mb_ok + mb_iconerror);
      end;
    end;
  end;
end;

procedure GravaCampo (vTabDest : TIBTable; vField, vOrig : String); Overload;
var i : Integer;
begin
  i:=vTabDest.FieldByName(vField).DisplayWidth;
  vTabDest.FieldByName(vField).AsString:=Copy(vOrig,1,i);
end;

procedure GravaCampo (vTabDest : TClientDataSet; vField, vOrig : String); Overload;
var i : Integer;
begin
  i:=vTabDest.FieldByName(vField).DisplayWidth;
  vTabDest.FieldByName(vField).AsString:=Copy(vOrig,1,i);
end;

procedure GravaCampo (vTabDest : TClientDataSet; vField: String; vOrig: Double); Overload;
begin
  vTabDest.FieldByName(vField).AsFloat:=vOrig;
end;

procedure Teclado1(Sender: TObject; var Key: Char; vNumero: Boolean);
begin
  if (vNumero = True) then begin
    if (key in [',', '.']) then key:=FormatSettings.DecimalSeparator;
    if not (CharInSet(Key,['0'..'9', #13, #8, ',' ,'-'])) then key:=#0;
  end;
  if Key = #13 then begin
    keybd_event(VK_Tab, 0, 0, 0);   Key := #0;
  end;
end;

procedure Inserir_Bound(vCampo, vType : String);
begin
  Tabelas.Inserir.ParamByName(vCampo).Clear;
  Tabelas.Inserir.ParamByName(vCampo).Bound:=true;
  if (vType = 'I') then Tabelas.Inserir.ParamByName(vCampo).DataType:=ftInteger;
  if (vType = 'F') then Tabelas.Inserir.ParamByName(vCampo).DataType:=ftfloat;
  if (vType = 'S') then Tabelas.Inserir.ParamByName(vCampo).DataType:=ftString;
  if (vType = 'D') then Tabelas.Inserir.ParamByName(vCampo).DataType:=ftDateTime;
  if (vType = 'T') then Tabelas.Inserir.ParamByName(vCampo).DataType:=ftTime;
  if (vType = 'B') then Tabelas.Inserir.ParamByName(vCampo).DataType:=ftBlob;
end;

procedure Campo_Obrigatorio(Sender : TObject; vMsg : String);
begin
  if (Trim(TEdit(Sender).Text) = '') OR (TEdit(Sender).Text = '  /  /  ') OR (TEdit(Sender).Text = '     -   ') then begin
    Screen.Cursor:=crDefault;
    Application.MessageBox(PChar(vMsg),'Argus', MB_OK + MB_ICONERROR);
    try
      TEdit(Sender).SetFocus;
    except
    end;
    abort;
  end;
end;

function Copia_ate_Caract(vCaract, vString : String; vRetornaApagado : Boolean) : String;
var iPos : Integer;
begin
  iPos:= Pos(vCaract, vString);
  if (vRetornaApagado = False) then // retorna parcial e não apaga da string
    result:= Copy(vString, 1, iPos - 1)
  else begin  // apaga da string os caracteres necessários
    Delete(vString, 1, iPos);
    result:= vString;
  end;
end;

procedure AbreFormEnderecoEstoque(vForm, vCap :String);
begin
  Application.CreateForm(TEndeEstoque, EndeEstoque);
  EndeEstoque.vForm:=vForm;
  EndeEstoque.Caption:=vCap;
  EndeEstoque.ShowModal;
  FreeAndNil(EndeEstoque);
end;

procedure LiberaMemoria;
var MainHandle : THandle;
begin
  try
    MainHandle := OpenProcess(PROCESS_ALL_ACCESS, false, GetCurrentProcessID) ;
    SetProcessWorkingSetSize(MainHandle, $FFFFFFFF, $FFFFFFFF) ;
    CloseHandle(MainHandle) ;
  except
  end;
  Application.ProcessMessages;
end;

function Carrega_LogoBanco(sBanco :String):String;
begin
  if (sBanco = '') then
    Result:=''
  else begin
    if (sBanco = 'Banco do Brasil') or (sBanco = 'Banco do Brasil simples') then
      Result:=ExtractFilePath(Application.ExeName) + 'BancosLogos\001.BMP';
    if (sBanco = 'Caixa Econômica') then
      Result:=ExtractFilePath(Application.ExeName) + 'BancosLogos\104.BMP';
    if (sBanco = 'Bradesco') then
      Result:=ExtractFilePath(Application.ExeName) + 'BancosLogos\237.BMP';
    if (sBanco= 'Santander') then
      Result:=ExtractFilePath(Application.ExeName) + 'BancosLogos\033.BMP';
    if (sBanco = 'Itaú') then
      Result:=ExtractFilePath(Application.ExeName) + 'BancosLogos\341.BMP';
    if (sBanco = 'Sicoob') then
      Result:=ExtractFilePath(Application.ExeName) + 'BancosLogos\756.BMP';
  end;
end;

function PrgRodando(Executavel: WideString): Boolean; Export; StdCall;
var ContinueLoop: BOOL;
    FSnapshotHandle: THandle;
    FProcessEntry32: TProcessEntry32;
begin
  FSnapshotHandle := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  FProcessEntry32.dwSize := SizeOf(FProcessEntry32);
  ContinueLoop := Process32First(FSnapshotHandle, FProcessEntry32);
  Result := False;
  while Integer(ContinueLoop) <> 0 do
  begin
    if ((UpperCase(ExtractFileName(FProcessEntry32.szExeFile)) =
      UpperCase(Executavel)) or (UpperCase(FProcessEntry32.szExeFile) =
      UpperCase(Executavel))) then
    begin
      Result := True;
    end;
    ContinueLoop := Process32Next(FSnapshotHandle, FProcessEntry32);
  end;
  CloseHandle(FSnapshotHandle);
end;

procedure DBGrid_CheckBox(Sender: TObject; vCampo, vValor : String; const Rect: TRect; DataCol: Integer; Column: TColumn; State: TGridDrawState);
var Check: Integer;
    R: TRect;
begin
  if Column.FieldName = vCampo then begin
    TDBGrid(Sender).Canvas.FillRect(Rect);
    Check := 0;
    if (UpperCase(Column.Field.asString) = UpperCase(vValor)) then
      Check := DFCS_CHECKED
    else
      Check := 0;
    R:=Rect;
    InflateRect(R,-2,-2); {Diminue o tamanho do CheckBox}
    DrawFrameControl(TDBGrid(Sender).Canvas.Handle,R,DFC_BUTTON, DFCS_BUTTONCHECK or Check);
  end; 
end;

function Arredonda_Centavos(vValor : String) : String;
var t,x:extended;
    q:integer;
begin
  q:=Length(vValor);
  t:=StrToFloat(vValor);
  x:=StrToFloat(copy(vValor,q,1));
  if (x < 5) then
    t:=t-(x/100)
  else begin
    t:=t-(x/100);
    t:=t+0.1;
  end;
  Result:=FormatFloat('##0.00',t);
end;

function IsNumeric(S : String) : Boolean;
begin
  Result := True;
  try
    StrToInt(S);
  except
    Result := False;
  end;
end;

function Verificar_Valor(Campo :String) : Boolean;
var vTemp :Double;
begin
  try
    vTemp:=StrToFloat(Campo);
    Result:=True;
  except
    Result:=False;
  end;
end;

procedure Vlr_Decimais(Sender : TObject);
begin
	if (TEdit(Sender).Text <> '') then begin
    TEdit(Sender).Text:= StringReplace(TEdit(Sender).Text, '.', '', [rfReplaceAll]);
		TEdit(Sender).Text:=formatfloat('##0.00', strtofloat(TEdit(Sender).Text));
	end;
end;

procedure Exibir_XML(vFile : String);
var IE : Variant;
begin 
  if not FileExists(vFile) then begin
    Application.MessageBox(pchar('O arquivo ' + vFile + ' não foi encontrado.'), 'Argus', mb_ok + mb_iconerror);
    Abort;
  end;
  IE := CreateOleObject('InternetExplorer.Application');
  IE.Visible := true;
  IE.Navigate(vFile);
end;

function GetWinDir: string;
var S: string;
    i: integer;
begin
  i := 255;
  SetLength(S, i);
  i := GetWindowsDirectory(PChar(S), i);
  SetLength(S, i);
  Result := Trim(S);
end;

function Verifica_DiaUtil_data(Data:Tdate;Dias:integer):Tdate;
var Datainicial, DataFinal:Tdate;
begin
  datainicial:=data+1;
  datafinal:=data+dias;
  while (Datainicial)<=Datafinal do begin
    if trunc(datainicial) mod 7 = 1 then
      datafinal:=Datafinal+2;
    datainicial:=datainicial+1;
  end;
  if trunc(datafinal) mod 7 = 1 then
    result:=datafinal+1
  else
    result:=datafinal;
end;

function GetAveCharSize(Canvas: TCanvas): TPoint;
var I: Integer;
    Buffer: array[0..51] of Char;
begin
  for I := 0 to 25 do Buffer[I] := Chr(I + Ord('A'));
  for I := 0 to 25 do Buffer[I + 26] := Chr(I + Ord('a'));
  GetTextExtentPoint(Canvas.Handle, Buffer, 52, TSize(Result));
  Result.X := Result.X div 52;
end;

function InputQueryArgus(const ACaption, APrompt: string; var Value: string; vMaxLenght:integer): Boolean;
var Form: TForm;
    Prompt: TLabel;
    Edit: TEdit;
    DialogUnits: TPoint;
    ButtonTop, ButtonWidth, ButtonHeight: Integer;
begin
  Result := False;
  Form := TForm.Create(Application);
  with Form do
    try
      Canvas.Font := Font;
      DialogUnits := GetAveCharSize(Canvas);
      BorderStyle := bsDialog;
      Caption := ACaption;
      ClientWidth := MulDiv(180, DialogUnits.X, 4);
      Position := poScreenCenter;
      Prompt := TLabel.Create(Form);
      with Prompt do begin
        Parent := Form;
        Caption := APrompt;
        Left := MulDiv(8, DialogUnits.X, 4);
        Top := MulDiv(8, DialogUnits.Y, 8);
        Constraints.MaxWidth := MulDiv(164, DialogUnits.X, 4);
        WordWrap := True;
      end;
      Edit := TEdit.Create(Form);
      with Edit do begin
        Parent := Form;
        Left := Prompt.Left;
        Top := Prompt.Top + Prompt.Height + 5;
        Width := MulDiv(164, DialogUnits.X, 4);
        MaxLength := vMaxLenght;
        Text := Value;
        SelectAll;
      end;
      ButtonTop := Edit.Top + Edit.Height + 15;
      ButtonWidth := MulDiv(50, DialogUnits.X, 4);
      ButtonHeight := MulDiv(14, DialogUnits.Y, 8);
      with TButton.Create(Form) do begin
        Parent := Form;
        Caption := 'OK';
        ModalResult := mrOk;
        Default := True;
        SetBounds(MulDiv(38, DialogUnits.X, 4), ButtonTop, ButtonWidth,
          ButtonHeight);
      end;
      with TButton.Create(Form) do begin
        Parent := Form;
        Caption := 'Cancel';
        ModalResult := mrCancel;
        Cancel := True;
        SetBounds(MulDiv(92, DialogUnits.X, 4), Edit.Top + Edit.Height + 15,
          ButtonWidth, ButtonHeight);
        Form.ClientHeight := Top + Height + 13;          
      end;
      if ShowModal = mrOk then begin
        Value := Edit.Text;
        Result := True;
      end;
    finally
      Form.Free;
    end;
end;


function ProdutoCalculaPrecoUnd(vOperacao :String; vIndice, vVista, vMarckup :double):double;
var vTemp :Double;
begin
  vTemp:=0;
  if (vOperacao = 'Multiplicar') then
    vTemp := vIndice * vVista
  else begin
    if (vIndice > 0) then
      vTemp := vVista / vIndice;
  end;
  Result := (vMarckup / 100 * vTemp) + vTemp;
end;

Function SeparaPalavras(Palavra, Campo: String): String;
var I: Integer;
    vTemp, vResultado :String;
begin
	vResultado:='';
	for I := 0 to length(Palavra) - 1 do
	begin
		if (Pos(' ', Palavra) > 0) and (Pos('*',String(Copy(Palavra,0,1))) = 0 ) then
		begin
			vTemp := Copy(Palavra, 1, Pos(' ', Palavra) - 1);
			Palavra := Copy(Palavra, Pos(' ', Palavra) + 1, Length(Palavra));

			if vTemp<> '' then
				vResultado:=vResultado + ' and ' + Campo +  ' containing(' + QuotedStr(vTemp) + ')';
		end
		else if (Pos('*',String(Copy(Palavra,0,1))) = 1 ) and (I=0) then begin //encontrou parâmetro de busca que contenha a palavra na primeira posição.

			if Pos(' ',String(Copy(Palavra,0,Length(Palavra)))) = 0 then begin
				vTemp := Copy(Palavra, 2,  Length(Palavra));
				Palavra := '';
			end
			else begin
				vTemp := Copy(Palavra, 2, Pos(' ', Palavra) - 2);
				Palavra := Copy(Palavra, Pos(' ', Palavra) + 1, Length(Palavra));
			end;

			if vTemp<> '' then
				vResultado:=vResultado + ' and ' + Campo +  ' LIKE ' + QuotedStr(vTemp + '%');
		end
		else
		begin
			vTemp := Palavra;
			Palavra := '';
			if vTemp<> '' then
				vResultado:=vResultado + ' and ' + Campo + ' containing(' + QuotedStr(vTemp) + ')';
		end;
	end;
 Result:=vResultado;

  { Giovani 04/10/19 - Alterado código para o de cima.

  vResultado:='';
  for I := 0 to length(Palavra) - 1 do
    begin
      if Pos(' ', Palavra) > 0 then
        begin
          vTemp := Copy(Palavra, 1, Pos(' ', Palavra) - 1);
          Palavra := Copy(Palavra, Pos(' ', Palavra) + 1, Length(Palavra));

          if vTemp<> '' then
            vResultado:=vResultado + ' and ' + Campo +  ' containing(' + QuotedStr(vTemp) + ')';
        end
      else
        begin
          vTemp := Palavra;
          Palavra := '';
          if vTemp<> '' then
            vResultado:=vResultado + ' and ' + Campo + ' containing(' + QuotedStr(vTemp) + ')';
        end;
    end;
   Result:=vResultado;}
end;

function CaractBase(Temp1 : String) : String;
begin
   Temp1:=StringReplace(Temp1, '-', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '_', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '/', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '\', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '''', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '"', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '.', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '´', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, ',', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, ':', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '(', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, ')', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, ';', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '`', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '*', '', [rfReplaceAll]);
   Result:=Temp1;
end;

function Caract(Temp1 : String) : String;
begin
   Temp1:=StringReplace(Temp1, '-', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '_', ' ', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '/', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '\', ' ', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '''', ' ', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '"', ' ', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'Ç', 'C', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '&', 'e', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'Á', 'A', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'À', 'A', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'É', 'E', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'Ú', 'U', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'Ã', 'A', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '.', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'Í', 'I', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'Ó', 'O', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '´', ' ', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'Õ', 'O', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'ª', ' ', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'º', ' ', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, ',', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'Â', 'A', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'Ê', 'E', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, ':', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'Ô', 'O', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'é', 'e', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '(', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, ')', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'ó', 'o', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '[', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, ']', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, ';', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '+', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'á', 'a', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'ã', 'a', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '`', ' ', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, 'Ò', 'O', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '*', '', [rfReplaceAll]);
   Result:=Temp1;
end;

function CaractADC(Temp1 : String) : String;
begin
   Temp1:=StringReplace(Temp1, ';', ',', [rfReplaceAll]);
   Result:=Temp1;
end;

function ApenasNumerosStr(Str: String): String;
var I: Integer;
begin
  Result := '';
  for I := 1 to Length(Str) do
    if Str[I] in ['1','2','3','4','5','6','7','8','9','0'] then
  Result := Result + Str[I];
end;

function IIf(Cond: Boolean; True, False: Variant): Variant;
begin
  if Cond then
    Result := True
  else
    Result := False;
end;

function CalculaCPF_CNPJ(Numero: String): Boolean;
var i, d, b, Digito : Byte;
    Soma : Integer;
    CNPJ : Boolean;
    DgPass, DgCalc : String;
begin
  Result := False;
  Numero := ApenasNumerosStr(Numero);
  Case Length(Numero) of
    11: CNPJ := False;
    14: CNPJ := True;
  else
    exit;
  end;
  DgCalc := '';
  DgPass := Copy(Numero,Length(Numero)-1,2);
  Numero := Copy(Numero,1,Length(Numero)-2);
  for d := 1 to 2 do begin
    B := IIF(D = 1,2,3); // BYTE
    SOMA := IIF(D = 1, 0, StrToIntdef(DGCALC, 0) * 2);
    for i := Length(Numero) downto 1 do begin
      Soma := Soma + (Ord(Numero[I]) - Ord('0')) * b;
      Inc(b);
      if (b > 9) and CNPJ then
        b := 2;
    end;
    Digito := 11 - Soma mod 11;
    if Digito >= 10 then
      Digito := 0;
    DgCalc := DgCalc + Chr(Digito + Ord('0'));
  end;
  Result := DgCalc = DgPass;
end;

function ValidaEAN(const vEAN:String):Boolean;
var Temp1, Temp2, Digito: Integer;
    Temp3, Temp4: String;
begin
  try
    Result := False;
    Temp2 := 0; Temp3 := '';
    if ((Length(vEan) <> 8) and (Length(vEan) <> 12) and (Length(vEan) <> 13) and (Length(vEan) <> 18)) then Exit;

    Temp4 := '31313131313131313';
    Temp4 := Copy(Temp4,(Length(Temp4)-Length(vEan)),Length(vEan)-1);
    Digito := StrToInt(Copy(vEan,Length(vEan),1));
    Temp3 := Copy(vEan,1,Length(vEan)-1);

    for Temp1 := 1 to Length(Temp3) do
      Temp2 := Temp2+StrToInt(Temp3[Temp1])*StrToInt(Temp4[Temp1]);

    Temp2:=10-Round(Frac(Temp2/10)*10);
    if Temp2 = 10 then Temp2 := 0;
    Result := (Temp2 = Digito);
  except
    Result := False;
  end;
end;

function Centralizar_Texto_Impressao(texto:String; tamanho :Integer):String;
var aux: Integer;
    textoCentralizado: String;
begin
  if (tamanho > length(texto)) then begin
    aux := trunc((tamanho - length(texto))/ 2);
    textoCentralizado := stringOfchar(' ',aux) + texto + stringOfchar(' ',aux);
    if (Length(textoCentralizado) < tamanho) then
      textoCentralizado := textoCentralizado+' ';
  end else
    textoCentralizado := texto;
  Result := textoCentralizado;
end;

function MsgDlgButtonPersonal(const Msg: string; DlgType: TMsgDlgType; Buttons: TMsgDlgButtons; Captions: array of string): Integer;
var aMsgDlg: TForm;
    CaptionIndex, i: Integer;
    dlgButton: TButton;
begin
  aMsgDlg := CreateMessageDialog(Msg, DlgType, Buttons);
  CaptionIndex := 0;
  for i := 0 to pred(aMsgDlg.ComponentCount) do begin  { Faz um loop varrendo os objetos do dialogo }
    if (aMsgDlg.Components[i] is TButton) then begin   { Apenas entra na condição se o objeto for um button }
      dlgButton := TButton(aMsgDlg.Components[i]);
      if CaptionIndex > High(Captions) then //Captura o Index dos captions dos buttons criado no array
         Break;
      dlgButton.Caption := Captions[CaptionIndex];
      Inc(CaptionIndex);
    end;
  end;
  Result := aMsgDlg.ShowModal;
end;

procedure AbreForm(vClasseForm: TComponentClass;var vForm ; vPermi : String);
begin
  if (vPermi <> '') then Verificacao_Acesso(vPermi);
  Application.CreateForm(vClasseForm,vForm);
  try
    Tform(vForm).ShowModal;
  finally
    FreeAndNil(Tform(vForm));
  end;
end;


procedure AbreFormConj(vClasseForm1: TComponentClass;var vForm1;vClasseForm2: TComponentClass;var vForm2);
begin
  Application.CreateForm(vClasseForm1,vForm1);
  Application.CreateForm(vClasseForm2,vForm2);
  try
    Tform(vForm1).ShowModal;
  finally
    FreeAndNil(Tform(vForm1));
    FreeAndNil(Tform(vForm2));
  end;
end;

procedure AbreFormRecibo(vValor, vNome, vEnde, vVenc, vEmissao, vCompra, vObs : String);
begin
  Application.CreateForm(TRecibo, Recibo);
  try
    Recibo.C_Valor.Text  := vValor;
    Recibo.C_Recebi.Text := vNome;
    Recibo.C_Ende.Text   := vEnde;
    Recibo.V_VENC:=vVenc;
    Recibo.V_EMISSAO:=vEmissao;
    Recibo.V_COMPRA:=vCompra;
    Recibo.V_OBS:=vObs;
    Recibo.ShowModal;
  finally
    FreeAndNil(Recibo);
  end;
end;

procedure AbreFormF5(vForm : String ; vDesco : Double);
begin
  Application.CreateForm(TF5, F5);
  try
    F5.vForm  := vForm;
    F5.vDesco := vDesco;
    F5.ShowModal;
  finally
    FreeAndNil(F5);
  end;
end;

procedure AbreRelat(vClasseForm: TComponentClass;var vForm ; vPermi : String);
begin
  if (vPermi <> '') then Verificacao_Acesso(vPermi);
  Application.CreateForm(vClasseForm,vForm);
  try
    TQuickRep(vForm).PreviewModal;
  finally
    FreeAndNil(TQuickRep(vForm));
  end;
end;

procedure ExportaExcel(pTabela: TDataSet; pAutoFit: Boolean);
var
  i: Integer;
  Sheet: Variant;
  X, C : Integer;
  Lista : TStrings ;

  function ConvertFormat( AFormat: String ): String;
  begin
    Result := FormatFloat( AFormat, 1110 );
    Result := StringReplace( Result, '1', '#', [rfReplaceAll] );
  end;

begin
  Screen.Cursor:=crHourGlass;
  XLApp:= CreateOleObject('Excel.Application');

  XLApp.Workbooks.Add(xlWBatWorkSheet);
  XLApp.Workbooks[1].WorkSheets[1].Name := 'Argus Data';

  Lista := TStringList.Create ;
  Lista.Clear ;
  pTabela.Fields.GetFieldNames( Lista );

  Sheet := XLApp.Workbooks[1].WorkSheets['Argus Data'];

  C := 1;
  For X := 1 To ( Lista.Count  )  do begin
    If not pTabela.Fields.Fields[ X - 1 ].Visible Then
       Continue;

     Sheet.Cells[ 1, C ] := pTabela.Fields[ X - 1 ].DisplayLabel;
     try
       Sheet.Cells[ 1, C ].ColumnWidth := pTabela.Fields[ X - 1 ].DisplayWidth;
     except
     end;
     Inc( C );
  End;

  pTabela.DisableControls;
  pTabela.First;
  i := 1;
  While not pTabela.Eof do begin
     inc(i);
     c := 1;
     For X := 1 To ( Lista.Count  )  do begin

        If not pTabela.Fields.Fields[ X - 1 ].Visible Then
          Continue;

        If (pTabela.Fields.Fields[ X - 1 ].DataType = ftString) or (pTabela.Fields.Fields[ X - 1 ].DataType = ftWideString)Then
           Sheet.Cells[i, C] := '''' + pTabela.Fields[ X - 1 ].AsString
        Else
           If pTabela.Fields.Fields[ X - 1 ].DataType = ftInteger then
              Sheet.Cells[i, C] := pTabela.Fields[ X - 1 ].AsInteger
           Else
              If pTabela.Fields.Fields[ X - 1 ].DataType = ftAutoInc then
                 Sheet.Cells[i, C] := pTabela.Fields[ X - 1 ].AsInteger
              Else
                 If pTabela.Fields.Fields[ X - 1 ].DataType = ftFloat then
                  begin
                    Sheet.Cells[i, C] := pTabela.Fields[ X - 1 ].AsFloat;
                    If TFloatField(pTabela.Fields[ X - 1 ]).DisplayFormat <> '' then
                      Sheet.Cells[i, C].NumberFormat := ConvertFormat( TFloatField(pTabela.Fields[ X - 1 ]).DisplayFormat );
                  end
                 Else
                    Sheet.Cells[i, C] := pTabela.Fields[ X - 1 ].Value ;

        Inc( C );
     End;

     pTabela.Next;

  End;
  pTabela.EnableControls;

  If pAutoFit then
    XLApp.Columns.AutoFit;
  XLApp.Rows.AutoFit;
  XLApp.Visible := True;

  Screen.Cursor:=crDefault;
end;

Function ValidaCaminho(vCaminho:TStringList):String;
var
  X: Integer;
  vFinal:String;
  vCam:string;
begin
  if Tabelas.tbEmpresas.Active = false then Tabelas.tbEmpresas.Active := true;

  vFinal := '';
  for X := 0 to vCaminho.Count - 1 do begin
     vCam := vCaminho.Strings[x] + Tabelas.tbEmpresasFIRMA.AsString;
     if (not DirectoryExists(vCam)) and (not DirectoryExists(vCaminho.Strings[x])) then vFinal := vFinal + #13#10 + 'Caminho: ' + vCaminho.Strings[x];
  end;
  result := vFinal;
  vCaminho.Free;
end;

function Coalesce(Value1: Variant): Variant;
begin
  if not VarIsNull(Value1) then
    Result := Value1
  else
    Result := 0
end;

procedure UCAF_Contas_Pagar(stp:string);
var M:TextFile;
handle:THandle;
begin
  AssignFile(M, ExtractFilePath(Application.ExeName) + 'Temp.txt');
  Rewrite(M);
  Writeln(M, Menu1.L_File_Firebird.Caption);
  Writeln(M, Menu1.CONFIG_DADOS[1].FANTASIA);
  Writeln(M, Menu1.CONFIG_DADOS[2].FANTASIA);
  CloseFile(M);
  MapaCalorInsere('CONTA_PAGAR');
  ShellExecute(handle, 'Open', pchar('Contas_Pagar.exe'), pchar(stp), nil, SW_SHOWNORMAL);
end;

procedure AbrirWhatsApp(sTelefone, sArq:string; Janela: HWND);
  function ProcessExists(exeFileName: string): Boolean;
  var
    ContinueLoop: BOOL;
    FSnapshotHandle: THandle;
    FProcessEntry32: TProcessEntry32;
  begin
    FSnapshotHandle := CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    FProcessEntry32.dwSize := SizeOf(FProcessEntry32);
    ContinueLoop := Process32First(FSnapshotHandle, FProcessEntry32);
    Result := False;
    while Integer(ContinueLoop) <> 0 do
    begin
      if ((UpperCase(ExtractFileName(FProcessEntry32.szExeFile)) =
        UpperCase(ExeFileName)) or (UpperCase(FProcessEntry32.szExeFile) =
        UpperCase(ExeFileName))) then
      begin
        Result := True;
      end;
      ContinueLoop := Process32Next(FSnapshotHandle, FProcessEntry32);
    end;
    CloseHandle(FSnapshotHandle);
  end;
var
  CaminhoWhats:string;
begin
  //if (sTelefone <> '') then begin
    AssignFile(M, ExtractFilePath(Application.ExeName)+'WhatsApp\WhatsApp_MSG.txt');
    Rewrite(M);
    Writeln(M, sTelefone);
    Writeln(M, sArq);
    CloseFile(M);
 // end;

  if ProcessExists('WhatsApp.exe') then begin
    AssignFile(M, ExtractFilePath(Application.ExeName)+'WhatsApp\WhatsApp_temp.txt');
    Rewrite(M);
    CloseFile(M);
  end
  else begin
    //CaminhoWhats:= ExtractFilePath(Application.ExeName) + 'WhatsApp\WhatsApp.exe';
    ShellExecute(Janela, 'Open', Pchar(ExtractFilePath(Application.ExeName)+'WhatsApp\WhatsApp.exe'), nil, nil, SW_SHOWNORMAL)
   //Winexec(pAnsiChar(CaminhoWhats),SW_SHOWNORMAL);
  end;
end;

function TabelaPrecoProduto(vordem: Double; vtabela: Integer):double;
var
  vPreco: String;
  vValor: Double;
begin
  case vtabela of
    0: vPreco := 'VISTA';
    1: vPreco := 'VISTA';
    2: vPreco := 'PRAZO';
    3: vPreco := 'PRECO3';
    4: vPreco := 'PRECO4';
  end;

  Tabelas.Inserir5.Close;
  Tabelas.Inserir5.SQL.Text := 'SELECT ' + vPreco + ' FROM PRODUTOS WHERE ORDEM=:ORDEM';
  Tabelas.Inserir5.ParamByName('ORDEM').AsFloat := vOrdem;
  Tabelas.Inserir5.Open;
  vValor := StrToFloatDef(Tabelas.Inserir5.FieldByName(vPreco).AsString, 0);
  Result := vValor;
end;

function CaractData(Temp1 : String) : String;
begin
   Temp1:=StringReplace(Temp1, '-', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '/', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, '\', '', [rfReplaceAll]);
   Temp1:=StringReplace(Temp1, ' ', '', [rfReplaceAll]);
   Result:=Temp1;
end;

function calcularDiferencaHoras(Dataf,datai:Tdate;HoraF,HoraI:ttime):TDateTime;
var DataHoraF,DataHoraI:TDateTime;
begin
  DataHoraF:=DataF+HoraF;
  DataHorai:=DataI+HoraI;
  if DataHoraI > DataHoraF then
    result:=DataHoraI - DataHoraF
  else
    result:=DataHoraF - DataHoraI;
end;

end.
